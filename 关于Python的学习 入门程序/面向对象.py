#面向过程
#核心思想:把一个需求分解成一系列要执行的步骤，然后按照步骤依次执行这些任务(关注的·是流程，步骤)
#适用场景:面向过程编辑非常直接，适合简单，线性的任务

# 面向对象编程
#对象可以理解为现实中具体的人/物在程序中的数字化身(万物皆对象)
#它把一个人/物的特征(属性)和功能(方法)打包到一起，是面向对象编程的基本单元(关注的是谁来帮我做这件事)

#类与对象
#类:描述的是一组具有相同属性(特征)和方法(功能/行为)的模板
#对象:对象是类的实例，是基于类创造出来的(实例对象)也就是说是按照模板创造出来的
#对象是由类创建出来的，创建对象的过程，也称为对象的实例化。一个类可以创建出无数的对象

#定义类
# class 类名: #其中类名的命名规范，遵循大驼峰命名法 每个单词的首字母都是大写，单词之间没有分隔符，比如:UserInfo,UseAcccount
#     pass#(pass是空语句) #定义类的结构
# #创建对象
# 对象名 = 类名()
# 对象名.属性1 = 属性值1
# 对象名.属性2 = 属性值2
#__dict__是Python中用户自定义实例的一个特殊属性 用于字典形式储存对象的属性 如 有对象c1  print(c1.__dict__)

#定义在类外面的称之为函数，定义在类里面的称之为方法
#__init__:初始化方法，对象创建后自动调用，主要用于设置对象的初始状态(设置对象属性)

# class 类名:
#     def __init__(self,参数列表): #self表示的是方法的第一个参数，表示当前创建的实例对象
#         self.属性名 = 参数值
#         self.属性名 = 参数值
# # 创建对象
# 对象名 = 类名(参数列表)


#实例方法
#在类中定义实例方法时，定义语法与之前学习的函数定义的方法是一致的
#定义类
# class 类名:
#     def __init__(self,形参列表):
#         self.属性名 = 参数值
#         self.属性名 = 参数值
#     def 方法名(self,形参方法):
#         ...
#     def 方法名(self,形参方法):
#         ...
# #创建对象
# 对象名 = 类名(参数列表)
# 对象名.方法名(实参)

##对于__init__ 当写了p = Person("张三",20)时，Python的执行顺序是:
#1.先创建一个空的Person实例(内存里的一个对象)
#2.Python自动把这个空实例赋值给__init__的第一个参数self(self=这个空实例)
#3.__init__执行内部代码，通过self.name = 张三   self.age = 20 ,把属性绑定到self代表的这个实例上
#__init__里的第一个形参是self，用来接收Python自动传过来的(实例本身)
#__init__里的其他参数(name/age):是用来接收你手动传入的属性值(张三/20)，作用是给self绑定属性时提供"值"，和self之间是"赋值绑定"关系，而非"传递"关系

# 魔法方法
#魔法方法指的是Python中提供以双下划线开头和结尾的特殊方法，用于定义类的特殊行为，比如:__init__
#魔法方法是不需要我们手动调用的，Python会在合适的时机自动调用
# __init__ 初始化方法 是专门用来定义一个类具有哪些属性的方法(用于属性的定义)
# __str__  字符串表示的方法
# __ep__   比较两个对象是否相等(equal)
# __lt__ , __le__, __gt__ ,__ge__   支持比较两个对象的大小(小于(less than),小于等于(less than or equal),大于(greater than),大于等于(greater than or equal)
# __del__  表示如果希望在对象被销毁去前 再去做一些事情 可以考虑一下此方法

# 属性
# 实例属性:实例属性属于每个具体对象的属性，每个对象都是独立的(各个对象特有的数据)-->通过  实例对象.属性 的方式操作
#类属性:类属性是属于类本身的属性，所有实例共享的(所有对象共享的数据或配置)-->通过 类名.属性的方式操作
#通过实例查找属性时，会先查找实例属性，实例属性不存在时，在查找类属性
# class 类名:
           #类属性
           # wheel = 4
#     def __init__(self,形参列表):
           #实例属性
#         self.属性名 = 参数值
#         self.属性名 = 参数值
#     def 方法名(self,形参方法):
#         ...
#     def 方法名(self,形参方法):
#         ...


#self 就是我正在操作的这辆车 car—A也是指这辆车的的名字 所以在代码上 self.xxx和car_A.xxx干的事情一摸一样
#把它们当成一个东西的两个名称就够了 比如车管自己叫self("我")  你管车叫acr_A("那辆车") 它们指向并控制同一个对象 所以在实际写代码的时候，完全可以把他们当成等价来理解和使用
# 类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用的
#特征被称为属性
#行为（功能）被称为方法
#类就相当于制造飞机时的图纸，是一个模板，是负责创建对象的

#对象是由类创建出来的一个具体存在，可以直接使用
#由哪一个类创建出来的对象，就拥有哪一个类中定义的:
#属性和方法
#对象就相当于用图纸制造的飞机

#在程序开发中，应该先有类，在有对象
#类只有一个，而对象可以有很多个

#dir内置函数
#在Python中对象是无所不在的 我们之前学习的变量，数据，函数都是对象 在Python中可以使用的以下两种方法验证
#在标识符/数据后输入一个. 然后按下Tab键iPyhon会提示该对象能够调用的方法列表
#使用内置函数dir传入标识符/数据 可以查看对象内的所有属性和方法

#在类封装的方法内部，self就表示当前调用方法的对象自己
#调用方法时，程序员不需要传递self参数
#在方法内部:
#可以通过self. 访问对象的属性
# 也可以通过self. 调用其他的对象方法

#del关键字可以删除一个对象
#生命周期
#一个对象在从调用 类名() 创建 生命周期开始
#一个对象的__del__方法一旦被调用，生命周期结束
#在对象的生命周期内，可以访问对象属性，或者让对象调用方法

# __str__在Python中 使用输出对象变量，默认情况下 会输出这个变量引用的对象是哪一个类创建的对象，以及在内存中的地址(十六进制表示)
#如果在开发中 希望使用print去输出对象变量时 能够打印自定义的内容 就可以利用__str__这个内置方法
#注意:__str__方法必须返回一个字符串

#一个对象的属性可以是其他类创建的方法
#封装是面向对象的一大特点
# 定义一个类 在其他类中我可以调用第一个类中的对象
#面向对象编程的第一步   将属性和方法封装到一个抽象的类中
# 外界使用类创建对象 然后让对象调用方法
# 对象方法的细节都被封装在类的内部

#身份运算符
#身份运算符用于比较两个对象的内存地址是否一致  是否是同一个对象的引用
#在Python中针对None的比较时2 建议使用is判断
# is 是判断两个标识符是不是引用同一个对象  x is y  类似于id(x)==id(y)
# is not 是判断两个标识符是不是引用不同的对象 x is y 类似于id(x) != id(y)
# is是用于判断两个变量引用对象(指向的内存地址)是否为同一个
# ==用于判断引用变量的值是否相等

# 私有属性和私有方法
# 在实际开发中 对象和某些属性或方法可能只希望在对象内部被使用 而不希望在外部被访问到
# 私有属性就是对象不希望公开的属性
#私有方法就是对象不希望公开的方法
#定义方法
#在定义属性和方法时 在属性名或者方法名前增加两个下划线 定义的就是私有属性或方法


# 继承(就是派生)
# 继承实现代码的重用 相同的代码不需要重复的编写
#继承的概念: 子类拥有父类的所有方法和属性
# 语法
# class 类名(父类名)：

#子类继承父类 可以直接享受父类中已经封装好的方法，不需要再次开发
#子类中应该根据职责 封装子类特有的属性和方法
# 继承的传递性:
# c类从b类继承b类又从a类继承
# 那么c类就具有b类和a类的所有属性和方法 如:金毛类继承狗类 狗类又继承动物类 金毛类就拥有狗类和动物类的所以属性和方法
#子类拥有父类以及父类的父类中封装的所有属性和方法

# 方法的重写
#应用场景: 当父类的方法实现不能满足子类的需求时 可以对方法进行重写(override)
#重写父类方法有两种情况
#1. 覆盖父类的方法
#2. 对父类方法进行扩展
#
#覆盖父类的方法
#如果在开发中 父类的方法实现和子类的方法实现完全不同 就可以使用覆盖的方式 在子类中重新编写父类的方法实现
#具体的实现方式 就相当于在子类中定义了一个和父类同名的方法并且实现
#重写之后 在运行时 只会调用子类中重写的方法 而不会调用父类的封装方法
#
#如果在开发中 子类方法的实现中包含了父类的方法实现
#父类原本封装的方法实现是子类方法的一部分 就可以使用扩展的方式 也就是说在父类的基础上扩展子类所需要的方法
#1. 在子类中重写父类的方法
#2. 在需要的位置使用 super().父类方法 来调用父类方法的执行(会将父类的方法调用出来)
#3. 代码其他的位置针对子类的需求 编写子类特有的代码实现
# 关于super
#在Python中super是一个特殊的类
# super() 就是使用super类创建出来的对象
# 最常用的场景就是在重写父类方法时 调用在父类封装的方法实现

#子类对象不能在自己方法内部 直接访问父类的私有属性或私有方法
#子类对象可以通过父类的公有方法间接访问到私有属性或私有方法 比如在父类公有方法中调用私有属性或方法 再从子类中调用该父类的公有方法 由此便可以间接的访问父类的私有属性和方法
# 私有属性和方法是对象的隐私 不对外公开 外界以及子类都不能直接访问
# 私有属性和方法通常用于做一些内部的事情


# 多继承
# 子类可以拥有多个父类 并且具有所有父类的属性和方法
# 例如: 孩子可以继承自己父亲和母亲的特性
