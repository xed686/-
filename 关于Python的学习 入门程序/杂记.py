# 按下Alt+shift不松手再用鼠标下拉可以进行列编辑
#ctrl+d 是快速复制一行
#ctrl+d 是快速复制一行
# _表示其他情况
#max()表示最大值  #min()表示最小值  #len()表示获取容器内元素的个数  #sum()表示求和
#round(数据,想保留几位小数) 能将一个小数点后数字多的数给简化
# enumerate 是 Python 内置函数，字面意思是 “枚举、列举”，核心作用是：遍历可迭代对象（列表、字符串、元组等）时，同时返回「元素的索引」和「元素本身」，避免手动维护索引变量，让代码更简洁、不易出错。
# 简单类比：就像你数苹果时，既说出 “第 1 个苹果”“第 2 个苹果”（索引），又说出苹果本身（元素）。

# map(处理函数, 可迭代对象) → 把「处理函数」逐个应用到「可迭代对象」的每一个元素上，返回一个迭代器（可以理解为 “待提取的处理结果”）；
#迭代器（iterator）是 Python 中一种「懒加载的可遍历对象」，可以理解为：
# 一个 “只在你需要的时候才产出下一个元素” 的 “数据生成器”，像自助餐厅的取餐机 —— 你按一次按钮（取一个元素），它才出一份餐，不会一次性把所有餐都摆出来；而列表 / 元组是 “装满所有餐的盘子”，一次性把所有数据都存在内存里。
#
# 对应代码里的 for _ in range(k):）中的 _ 是 Python 里的一个特殊变量名，核心作用是：表示 “我不需要使用这个循环变量，只是单纯需要循环指定次数”。


# join() 是 Python 字符串的内置方法，核心作用是：将一个「可迭代对象（如列表、元组）」中的所有字符串元素，用指定的「分隔符字符串」连接成一个新的完整字符串。
# 简单类比：join() 就像 “串糖葫芦”—— 分隔符是 “糖签”，可迭代对象里的元素是 “山楂”，最终串成一串完整的糖葫芦（新字符串）。
#  分隔符字符串.join(可迭代对象)
# 分隔符字符串可以是空字符串、单个字符、多个字符（比如 ""、"-"、"++"）；
# 可迭代对象必须是「所有元素都是字符串」的对象（列表、元组、字符串等）；
# 返回值：连接后的完整新字符串。
# # 例子1：用空字符串连接（无分隔符，直接拼接）
# lst = ["8", "2", "5"]
# result = "".join(lst)  # 分隔符是空字符串
# print(result)  # 输出："825"（核心：拼接成完整字符串）
#   
# # 例子2：用"-"连接
# lst = ["a", "b", "c"]
# result = "-".join(lst)
# print(result)  # 输出："a-b-c"
#
# # 例子3：用"++"连接
# lst = ["1", "2", "3"]
# result = "++".join(lst)
# print(result)  # 输出："1++2++3"

# Python 中的 Counter，它是 collections 模块里的一个实用工具，核心作用是快速统计可迭代对象中元素的出现次数（比如列表、字符串、元组等），返回一个类似字典的键值对（键 = 元素，值 = 出现次数）
# from collections import Counter
# # 1. 统计列表元素
# nums = [1, 2, 2, 3, 3, 3, 7, 7, 7, 7]
# count = Counter(nums)
# print(count)  # 输出：Counter({7: 4, 3: 3, 2: 2, 1: 1})

# isinstance() 是 Python 的内置函数，作用是：判断一个对象（变量）是否是指定的类型，或指定类型的子类实例。简单来说，它就是用来 “检查数据类型” 的工具，语法格式如下：
# isinstance(待检查的对象, 目标类型/类型元组)

# 关于二维列表创建的注意事项 如下：
# 不要用 [[0]*cols]*rows 创建！这种写法会导致所有行指向同一个子列表，修改一行会影响所有行：
# 错误示例：
# bad_matrix = [[0]*3]*2
# bad_matrix[0][0] = 1  # 修改第0行第0列
# print(bad_matrix)  # 输出：[[1,0,0], [1,0,0]] → 第1行也被修改了！
# # 正确示例（列表推导式）：
# good_matrix = [[0 for _ in range(3)] for _ in range(2)]
# good_matrix[0][0] = 1
# print(good_matrix)  # 输出：[[1,0,0], [0,0,0]] → 仅修改目标行
